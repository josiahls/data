${init_base}

########################################################################################################################
# The part below is generated by parsing through the Python files where IterDataPipes are defined.
# This base template ("__init__.pyi.in") is generated from mypy stubgen with minimal editing for code injection
# The output file will be "__init__.pyi".
# Note that, for mypy, .pyi file takes precedent over .py file, such that we must define the interface for other
# classes/objects here, even though we are not injecting extra code into them at the moment.

from .util.extractor import CompressionType
from torchdata.datapipes.map import MapDataPipe
from torch.utils.data import DataChunk, IterableDataset
from torch.utils.data._typing import _DataPipeMeta

from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, TypeVar, Union

try:
    import torcharrow
except ImportError:
    torcharrow = None

T_co = TypeVar("T_co", covariant=True)

class IterDataPipe(IterableDataset[T_co], metaclass=_DataPipeMeta):
    functions: Dict[str, Callable] = ...
    reduce_ex_hook: Optional[Callable] = ...
    getstate_hook: Optional[Callable] = ...
    def __getattr__(self, attribute_name: Any): ...
    @classmethod
    def register_function(cls, function_name: Any, function: Any) -> None: ...
    @classmethod
    def register_datapipe_as_function(
        cls, function_name: Any, cls_to_register: Any, enable_df_api_tracing: bool = ...
    ): ...
    def __getstate__(self): ...
    def __reduce_ex__(self, *args: Any, **kwargs: Any): ...
    @classmethod
    def set_getstate_hook(cls, hook_fn: Any) -> None: ...
    @classmethod
    def set_reduce_ex_hook(cls, hook_fn: Any) -> None: ...
    # Functional form of 'BatcherIterDataPipe'
    def batch(self, batch_size: int, drop_last: bool = False, wrapper_class=DataChunk) -> IterDataPipe: ...
    # Functional form of 'CollatorIterDataPipe'
    def collate(
        self, collate_fn: Callable = ..., fn_args: Optional[Tuple] = None, fn_kwargs: Optional[Dict] = None
    ) -> IterDataPipe: ...
    # Functional form of 'ConcaterIterDataPipe'
    def concat(self, *datapipes: IterDataPipe) -> IterDataPipe: ...
    # Functional form of 'RoutedDecoderIterDataPipe'
    def decode(self, *handlers: Callable, key_fn: Callable = ...) -> IterDataPipe: ...
    # Functional form of 'DemultiplexerIterDataPipe'
    def demux(
        self,
        num_instances: int,
        classifier_fn: Callable[[T_co], Optional[int]],
        drop_none: bool = False,
        buffer_size: int = 1000,
    ) -> List[IterDataPipe]: ...
    # Functional form of 'FilterIterDataPipe'
    def filter(
        self,
        filter_fn: Callable,
        fn_args: Optional[Tuple] = None,
        fn_kwargs: Optional[Dict] = None,
        drop_empty_batches: bool = True,
    ) -> IterDataPipe: ...
    # Functional form of 'ForkerIterDataPipe'
    def fork(self, num_instances: int, buffer_size: int = 1000) -> List[IterDataPipe]: ...
    # Functional form of 'GrouperIterDataPipe'
    def groupby(
        self,
        group_key_fn: Callable,
        *,
        buffer_size: int = 10000,
        group_size: Optional[int] = None,
        unbatch_level: int = 0,
        guaranteed_group_size: Optional[int] = None,
        drop_remaining: bool = False,
    ) -> IterDataPipe: ...
    # Functional form of 'MapperIterDataPipe'
    def map(
        self,
        fn: Callable,
        input_col=None,
        output_col=None,
        *,
        fn_args: Optional[Tuple] = None,
        fn_kwargs: Optional[Dict] = None,
    ) -> IterDataPipe: ...
    # Functional form of 'MultiplexerIterDataPipe'
    def mux(self, *datapipes) -> IterDataPipe: ...
    # Functional form of 'ShardingFilterIterDataPipe'
    def sharding_filter(self) -> IterDataPipe: ...
    # Functional form of 'ShufflerIterDataPipe'
    def shuffle(self, *, default: bool = True, buffer_size: int = 10000, unbatch_level: int = 0) -> IterDataPipe: ...
    # Functional form of 'UnBatcherIterDataPipe'
    def unbatch(self, unbatch_level: int = 1) -> IterDataPipe: ...
    # Functional form of 'ZipperIterDataPipe'
    def zip(self, *datapipes: IterDataPipe) -> IterDataPipe: ...
    ${IterDataPipeMethods}
